#include <Arduino.h>
#include <assert.h>
#include "rom.h"
#include "debug.h"
#include "clock.h"
#include "z80.h"
#include "z80io.h"
#include "mmu.h"
#include "irq.h"
#include "disk.h"
#include "disasm.h"

#define MEMORY_WIPE_VALUE 0x76 // at reset, fill RAM with HALT instructions
#undef MODE_SWITCH_DEBUGGING   // debug switching between Z80 interface modes
/*
 * MODE_UNSUPERVISED, MODE_SUPERVISED, MODE_ENCHANTED:
 *
 * In MODE_UNSUPERVISED the Z80 runs from an asynchronous clock which is
 * generated by an external crystal oscillator or the Teensy FTM.
 * 
 * In MODE_SUPERVISED the Z80 runs from a synthesised clock generated in
 * software on the Teensy. Clock edges appear under Teensy program control
 * but the spacing between them (ie max clock frequency) is still moderated 
 * by the FTM.
 *
 * In MODE_ENCHANTED the SRAM is disabled so the Teensy can feed in
 * synthesised instructions. This is used to access the Z80 internal state
 * without disrupting the contents of SRAM.
 *
 * 
 * DMA states:
 *
 * Normally the Z80 is bus master, ie in control of the memory and I/O 
 * control signal, address and data lines.
 *
 * DMA_IDLE: The Z80 is in DMA mode, we can control the bus but we are not 
 * driving any control, address or data lines.
 *
 * DMA_READ: We are driving control and address lines.
 *
 * DMA_WRITE: We are driving control, address and data lines.
 */

z80_bus_trace_t z80_bus_trace = TR_SILENT;
z80_mode_t z80_mode = MODE_SUPERVISED;
int ram_pages;     // count of 16KB SRAM pages

static void z80_mode_dma_idle(void)
{
    // the transition has already happened, we just need to update the state
#ifdef MODE_SWITCH_DEBUGGING
    report("[%s->", z80_mode_name(z80_mode));
#endif
    switch(z80_mode){
        case MODE_UNSUPERVISED:
            z80_mode = MODE_UNSUPERVISED_DMA_IDLE;
            break;
        case MODE_SUPERVISED:
            z80_mode = MODE_SUPERVISED_DMA_IDLE;
            break;
        default:
            assert(false); // we shouldn't get called in any other modes
    }
#ifdef MODE_SWITCH_DEBUGGING
    report("%s]", z80_mode_name(z80_mode));
#endif
}

void z80_clock_pulse_drive_data(uint8_t data)
{
    z80_bus_data_outputs();
    z80_bus_set_data(data);

    do{
        z80_clock_pulse();
    }while( z80_rd_asserted() );

    z80_bus_data_inputs();
}

void z80_clock_pulse_while_writing(void)
{
    do{
        z80_clock_pulse();
    }while( z80_wr_asserted() );
}

void z80_do_reset(void)
{
    z80_clk_pause(false);
    z80_set_reset(true);
    z80_set_release_wait(true);
    for(int i=0; i<10; i++){ // Z80 requires at least 3 clocks to fully reset
        z80_set_clk(false);
        z80_set_clk(true);
    }
    z80_set_release_wait(false);
    z80_set_reset(false);
    z80_clk_resume();
}

void z80_memory_write(uint16_t address, uint8_t data)
{
    z80_set_dma_mode(true);
    z80_bus_set_address_data(address, data);
    z80_set_mreq(true);
    z80_set_wr(true);
    delayMicroseconds(1);
    z80_set_wr(false);
    z80_set_mreq(false);
}

uint8_t z80_memory_read(uint16_t address)
{
    uint8_t byte;
    z80_set_dma_mode(false);
    z80_bus_set_address(address);
    z80_set_mreq(true);
    z80_set_rd(true);
    delayMicroseconds(1);
    byte = z80_read_bus_data();
    z80_set_rd(false);
    z80_set_mreq(false);
    return byte;
}

void z80_memory_write_block(uint16_t address, const uint8_t *dataptr, uint16_t count)
{
    if(count == 0)
        return;

    z80_set_dma_mode(true);

    z80_set_mreq(true);
    while(count){
        z80_bus_set_address_data(address, *(dataptr++));
        z80_set_wr(true);
        count--;
        address++;
        z80_set_wr(false);
    }
    z80_set_mreq(false);
}

void z80_memory_read_block(uint16_t address, uint8_t *dataptr, uint16_t count)
{
    if(count == 0)
        return;

    z80_set_dma_mode(false);

    z80_set_mreq(true);
    z80_set_rd(true);
    while(count){
        z80_bus_set_address(address);
        address++;
        count--;
        *(dataptr++) = z80_read_bus_data();
    }
    z80_set_rd(false);
    z80_set_mreq(false);
}

void z80_wipe_page(void) // wipe the 16KB memory page in bank 0
{
    z80_set_dma_mode(true);

    z80_bus_set_address_data(0, MEMORY_WIPE_VALUE); // fill RAM with 0x76 (HALT instruction)
    z80_set_mreq(true);
    z80_set_wr(true);
    for(int i=1; i<0x4000; i++){
        z80_bus_set_address(i);
    }
    z80_set_wr(false);
    z80_set_mreq(false);
}

// Z80 CPU conducts a write to memory
uint8_t z80_enchanted_cpu_read(uint16_t *address=NULL)
{
    uint8_t data;

    // wait for write cycle to begin
    while(!(z80_mreq_asserted() && z80_wr_asserted()))
        z80_clock_pulse();

    // capture the cycle
    if(address)
        *address = z80_read_bus_address();
    data = z80_read_bus_data();

    // wait for write cycle to complete
    do{
        z80_clock_pulse();
    }while( z80_wr_asserted() );

    // return value written
    return data;
}

// Z80 CPU conducts a read from memory
uint16_t z80_enchanted_cpu_write(uint8_t data)
{
    uint16_t address;

    // wait for read cycle to begin
    while(!(z80_mreq_asserted() && z80_rd_asserted()))
        z80_clock_pulse();

    // capture address
    address = z80_read_bus_address();

    // put the byte on the data bus
    z80_bus_data_outputs();
    z80_bus_set_data(data);

    // wait for the read cycle to complete
    do{
        z80_clock_pulse();
    }while( z80_rd_asserted() );

    // release the data bus
    z80_bus_data_inputs();

    // return address read
    return address;
}

uint16_t z80_enchanted_cpu_read16(uint16_t *address = NULL)
{
    return (z80_enchanted_cpu_read(address) << 8) | z80_enchanted_cpu_read();
}

uint16_t z80_enchanted_cpu_write16(uint16_t value)
{
    uint16_t r;
    r = z80_enchanted_cpu_write(value);
    z80_enchanted_cpu_write(value >> 8);
    return r;
}

uint16_t z80_set_register_swap_registers(z80_register_t reg)
{
    switch(reg){
        case Z80_REG_AF_ALT:
            return z80_enchanted_cpu_write(0x08);   // EX AF, AF'
        case Z80_REG_BC_ALT:
        case Z80_REG_DE_ALT:
        case Z80_REG_HL_ALT:
            return z80_enchanted_cpu_write(0xD9);   // EXX
        default:
            return 0;
    }
}

void z80_set_register(z80_register_t reg, uint16_t value)
{
    uint16_t orig_pc, orig_sp, orig_af;

    // Sequence of instructions for loading each register:
    //
    //     PC:                                                        JP xx xx
    //     SP:                                          LD SP, xx xx; JP xx xx
    //     AF:              POP AF <xx xx>;             LD SP, xx xx; JP xx xx
    //     BC:              LD BC, xx xx;                             JP xx xx
    //     DE:              LD DE, xx xx;                             JP xx xx
    //     HL:              LD HL, xx xx;                             JP xx xx
    //     IX:              LD IX, xx xx;                             JP xx xx
    //     IY:              LD IY, xx xx;                             JP xx xx
    // AF_ALT:  EX AF, AF'; POP AF <xx xx>; EX AF, AF'; LD SP, xx xx; JP xx xx
    // BC_ALT:  EXX;        LD BC, xx xx;   EXX;                      JP xx xx
    // DE_ALT:  EXX;        LD DE, xx xx;   EXX;                      JP xx xx
    // HL_ALT:  EXX;        LD HL, xx xx;   EXX;                      JP xx xx
    //      I:  PUSH AF <xx xx>; LD A, xx; LD I, a; POP AF <xx xx>; LD SP, xx xx; JP xx xx
    z80_mode_t prev_mode = z80_set_mode(MODE_ENCHANTED);

    switch(reg){
        case Z80_REG_I:
            orig_pc = z80_enchanted_cpu_write(0xF5);  // PUSH AF
            orig_af = z80_enchanted_cpu_read16(&orig_sp);
            z80_enchanted_cpu_write(0x3E);  // LD A, xx
            z80_enchanted_cpu_write(value); // new value for I
            z80_enchanted_cpu_write(0xED);  // LD I, A
            z80_enchanted_cpu_write(0x47);  // (2-byte instruction)
            z80_enchanted_cpu_write(0xF1);  // POP AF
            z80_enchanted_cpu_write16(orig_af);
            break;
        case Z80_REG_PC:
            orig_pc = value;
            break;
        case Z80_REG_SP:
            orig_pc = z80_enchanted_cpu_write(0x31);     // LD SP
            break;
        case Z80_REG_AF:
            orig_pc = z80_enchanted_cpu_write(0xF1);     // POP AF -- can't do LD AF
            break;
        case Z80_REG_BC:
            orig_pc = z80_enchanted_cpu_write(0x01);     // LD BC
            break;
        case Z80_REG_DE:
            orig_pc = z80_enchanted_cpu_write(0x11);     // LD DE
            break;
        case Z80_REG_HL:
            orig_pc = z80_enchanted_cpu_write(0x21);     // LD HL
            break;
        case Z80_REG_AF_ALT:
            orig_pc = z80_set_register_swap_registers(reg);
            z80_enchanted_cpu_write(0xF1);               // POP AF -- can't do LD AF
            break;
        case Z80_REG_BC_ALT:
            orig_pc = z80_set_register_swap_registers(reg);
            z80_enchanted_cpu_write(0x01);               // LD BC
            break;
        case Z80_REG_DE_ALT:
            orig_pc = z80_set_register_swap_registers(reg);
            z80_enchanted_cpu_write(0x11);               // LD DE
            break;
        case Z80_REG_HL_ALT:
            orig_pc = z80_set_register_swap_registers(reg);
            z80_enchanted_cpu_write(0x21);               // LD HL
            break;
        case Z80_REG_IX:
            orig_pc = z80_enchanted_cpu_write(0xDD);     // ...
            z80_enchanted_cpu_write(0xE1);               // POP IX
            break;
        case Z80_REG_IY:
            orig_pc = z80_enchanted_cpu_write(0xFD);     // ...
            z80_enchanted_cpu_write(0xE1);               // POP IY
            break;
    }

    // where required, feed in the data value (and capture SP for POP instructions)
    switch(reg){
        case Z80_REG_I:
        case Z80_REG_PC:
            break;
        default:
            orig_sp = z80_enchanted_cpu_write16(value);
            break;
    }

    // where required, restore SP
    switch(reg){
        case Z80_REG_AF:
        case Z80_REG_AF_ALT:
        case Z80_REG_IX:
        case Z80_REG_IY:
        case Z80_REG_I:
            z80_enchanted_cpu_write(0x31);      // LD SP, xxxx
            z80_enchanted_cpu_write16(orig_sp + 1);
            break;
        default:
            break;
    }

    // switch register set back (NOP if not required)
    z80_set_register_swap_registers(reg);

    // pick up in real memory back where we started
    z80_enchanted_cpu_write(0xC3);              // JP, xxxx
    z80_enchanted_cpu_write16(orig_pc);

    z80_set_mode(prev_mode);
}

void z80_show_regs(void)
{
    uint16_t pc, sp, af, bc, de, hl, ix, iy, af_, bc_, de_, hl_;
    uint8_t i;

    // this code does not deal with the situation where CPU is HALTed.
    // solution might be: wake CPU with an int/nmi, capture PC when it writes it to the
    //                    stack. capture regs as usual. then IRET and JP to PC-1, then
    //                    feed it a HALT when it fetches PC-1. it will HALT with PC correct.

    // take over the CPU
    z80_mode_t prev_mode = z80_set_mode(MODE_ENCHANTED);

    // we feed it an F5 (PUSH AF) instruction
    pc = z80_enchanted_cpu_write(0xF5); // PUSH AF; capture PC

    af = z80_enchanted_cpu_read16(&sp); // capture both SP and AF
    sp += 1;                            // adjust SP to previous value

    z80_enchanted_cpu_write(0xC5);      // PUSH BC
    bc = z80_enchanted_cpu_read16();
    z80_enchanted_cpu_write(0xD5);      // PUSH DE
    de = z80_enchanted_cpu_read16();
    z80_enchanted_cpu_write(0xE5);      // PUSH HL
    hl = z80_enchanted_cpu_read16();
    z80_enchanted_cpu_write(0x08);      // EX AF, AF'
    z80_enchanted_cpu_write(0xF5);      // PUSH AF
    af_ = z80_enchanted_cpu_read16();
    z80_enchanted_cpu_write(0x08);      // EX AF, AF' again (swap back)
    z80_enchanted_cpu_write(0xD9);      // EXX
    z80_enchanted_cpu_write(0xC5);      // PUSH BC
    bc_ = z80_enchanted_cpu_read16();
    z80_enchanted_cpu_write(0xD5);      // PUSH DE
    de_ = z80_enchanted_cpu_read16();
    z80_enchanted_cpu_write(0xE5);      // PUSH HL
    hl_ = z80_enchanted_cpu_read16();
    z80_enchanted_cpu_write(0xD9);      // EXX again (swap back)
    z80_enchanted_cpu_write(0xDD);      // IX prefix
    z80_enchanted_cpu_write(0xE5);      // PUSH IX
    ix = z80_enchanted_cpu_read16();
    z80_enchanted_cpu_write(0xFD);      // IY prefix
    z80_enchanted_cpu_write(0xE5);      // PUSH IY
    iy = z80_enchanted_cpu_read16();
    z80_enchanted_cpu_write(0xED);      // ED prefix
    z80_enchanted_cpu_write(0x57);      // LD A,I - note this affects the flags register

    z80_enchanted_cpu_write(0xF5);      // PUSH AF
    i = z80_enchanted_cpu_read16()>>8;  // I was copied into A (top bits)

    // finally we need to put AF, SP and PC back as they were before our tinkering
    z80_enchanted_cpu_write(0xF1);      // POP af
    z80_enchanted_cpu_write16(af);
    z80_enchanted_cpu_write(0x31);      // LD SP, xxxx
    z80_enchanted_cpu_write16(sp);
    z80_enchanted_cpu_write(0xC3);      // JP xxxx
    z80_enchanted_cpu_write16(pc);

    // release the CPU
    z80_set_mode(prev_mode);

    report("PC=%04x SP=%04x\r\nAF=%04x AF'=%04x\r\n" \
           "BC=%04x BC'=%04x\r\nDE=%04x DE'=%04x\r\n" \
           "HL=%04x HL'=%04x\r\nIX=%04x IY=%04x I=%02x\r\n",
           pc, sp, af, af_,
           bc, bc_, de, de_,
           hl, hl_, ix, iy, i);
}

inline void z80_complete_read(uint8_t data)
{
    z80_bus_data_outputs();
    z80_bus_set_data(data);
    z80_set_busrq(true);
    z80_set_release_wait(true);
    while(!z80_busack_asserted())
        if(!z80_clk_is_independent())
            z80_clock_pulse();
    z80_bus_data_inputs();
    z80_set_release_wait(false);
    z80_mode_dma_idle();
}

inline void z80_complete_write(void)
{
    z80_set_busrq(true);
    z80_set_release_wait(true);
    while(!z80_busack_asserted())
        if(!z80_clk_is_independent())
            z80_clock_pulse();
    z80_set_release_wait(false);
    z80_mode_dma_idle();
}

void handle_z80_bus(void)
{
    if(z80_wait_asserted()){
        if(z80_iorq_asserted()){
            if(z80_rd_asserted()){       // I/O read
                z80_complete_read(iodevice_read(z80_read_bus_address()));
            }else if(z80_wr_asserted()){ // I/O write
                z80_complete_write();
                iodevice_write(z80_read_bus_address_low8(), z80_read_bus_data());
            }else if(z80_m1_asserted()){ // Interrupt acknowledge
                z80_complete_read(z80_irq_vector());
            }else
                report("ersatz80: iorq weird?\r\n");
        } else if(z80_mreq_asserted()){
            if(z80_rd_asserted()){       // Memory read
                z80_complete_read(memory_read(z80_read_bus_address()));
            }else if(z80_wr_asserted()){ // Memory write
                z80_complete_write();
                memory_write(z80_read_bus_address_low8(), z80_read_bus_data());
            }else
                report("ersatz80: mreq weird?\r\n");
        } else
            report("ersatz80: wait weird?\r\n");

        z80_end_dma_mode(); // Hmmmmmm. Can we safely get rid of this?
    }
}

void sram_setup(void)
{
    int i;
    uint8_t old_mmu = z80_get_mmu(0); // stash current MMU state

    // wipe RAM
    report("ersatz80: wipe RAM: page ___");
    for(i=0; i<256; i++){
        report("\x08\x08\x08%03d", i);
        z80_set_mmu(0, i);
        // is it really there?
        z80_memory_write(0, 0xaa);
        z80_memory_write(1, 0x55);
        z80_memory_write(2, 0x00);
        z80_memory_write(3, i);
        z80_memory_write(16383, i);
        z80_memory_write(16382, 0x00);
        z80_memory_write(16381, 0x55);
        z80_memory_write(16380, 0xaa);
        if(z80_memory_read(0) != 0xaa ||
           z80_memory_read(1) != 0x55 ||
           z80_memory_read(2) != 0x00 ||
           z80_memory_read(3) != i ||
           z80_memory_read(16380) != 0xaa ||
           z80_memory_read(16381) != 0x55 ||
           z80_memory_read(16382) != 0x00 ||
           z80_memory_read(16383) != i)
            break;
        // yup, it seems to be there!
        z80_wipe_page();
    }
    ram_pages = i;
    report("\x08\x08\x08\x08\x08\x08\x08\x08%d pages (%dKB)\r\n", ram_pages, 16*ram_pages);

    // return machine to previous state
    z80_set_mmu(0, old_mmu);
}

void load_program_to_sram(const uint8_t *program, uint16_t address, uint16_t length, uint16_t start_address)
{
    z80_set_dma_mode(true);

    z80_memory_write_block(address, program, length);

    if(start_address != 0 && address != 0){
        z80_memory_write(0, 0xc3); // JP instruction
        z80_memory_write(1, start_address & 0xFF);
        z80_memory_write(2, start_address >> 8);
    }
}

#define LOAD_BUFFER_SIZE 512
int load_file_to_sram(char *filename, uint16_t address)
{
    SdBaseFile file;
    uint8_t buffer[LOAD_BUFFER_SIZE];
    int r, total;

    // Open file
    if(!file.open(&sdcard, filename, O_RDONLY))
        return -1;

    // enter DMA mode
    z80_set_dma_mode(true);

    // Load the file block by block
    total = 0;
    while(true){
        r = file.read(buffer, LOAD_BUFFER_SIZE);
        if(r <= 0)
            break;
        z80_memory_write_block(address, buffer, r);
        address += r;
        total += r;
    }

    file.close();

    return total;
}

enum bus_cycle_t { MEM_READ, MEM_WRITE, IO_READ, IO_WRITE, NO_CYCLE };

typedef struct {
    bus_cycle_t cycle;
    uint16_t address;
    uint8_t data;
} bus_trace_t;

#define MAX_BUS_STATES 8 // presumably this can be lower??
bus_trace_t bus_trace[MAX_BUS_STATES];
bool bus_trace_wait_cycle_end = false;
int instruction_clock_cycles = 0;
int bus_trace_count = 0;
int bus_trace_di = 0;

uint8_t read_bus_trace_bytes(void)
{
    return bus_trace[bus_trace_di++].data;
}

void z80_instruction_ended(void)
{
    char output[20];
    uint16_t addr;
    bus_cycle_t cycle;

    if(z80_bus_trace >= TR_INST){
        bus_trace_di = 0;
        z80ctrl_disasm(read_bus_trace_bytes, output);
        report("%-14s %2d  ", output, instruction_clock_cycles);

        addr = ~bus_trace[0].address;
        for(int i=0; i<bus_trace_count; i++){
            if(bus_trace[i].address != addr || cycle != bus_trace[i].cycle){
                addr = bus_trace[i].address;
                cycle = bus_trace[i].cycle;
                switch(bus_trace[i].cycle){
                    case MEM_READ:  report("%04x: ", bus_trace[i].address); break;
                    case MEM_WRITE: report("%04x<-", bus_trace[i].address); break;
                    case IO_READ:   report("io%04x: ", bus_trace[i].address); break;
                    case IO_WRITE:  report("io%04x<-", bus_trace[i].address); break;
                    case NO_CYCLE:  break; // should never happen
                }
            }
            report("%02x%s", bus_trace[i].data, i == (bus_trace_count-1) ? "" : (i == (bus_trace_di-1) ? " / " : " "));
            addr++;
        }
        report("\r\n");
    }

    instruction_clock_cycles = 0;
}

void z80_bus_trace_state(void)
{
    bus_cycle_t type = NO_CYCLE;

    instruction_clock_cycles++;
    if(bus_trace_wait_cycle_end && !(z80_mreq_asserted() || z80_iorq_asserted()))
        bus_trace_wait_cycle_end = false;
    else if(!bus_trace_wait_cycle_end && !z80_wait_asserted()){
        if(z80_mreq_asserted()){
            if(z80_rd_asserted()){
                type = MEM_READ;
            }else if(z80_wr_asserted()){
                type = MEM_WRITE;
            }
        }else if(z80_iorq_asserted()){
            if(z80_rd_asserted()){
                type = IO_READ;
            }else if(z80_wr_asserted()){
                type = IO_WRITE;
            }
        }
        if(type != NO_CYCLE){
            if(z80_m1_asserted() && !(bus_trace_count == 1 && (bus_trace[0].data == 0xcb || bus_trace[0].data == 0xdd || bus_trace[0].data == 0xed || bus_trace[0].data == 0xfd))){
                z80_instruction_ended();
                bus_trace_count = 0;
            }
            bus_trace_wait_cycle_end = true;
            bus_trace[bus_trace_count].cycle = type;
            bus_trace[bus_trace_count].data = z80_read_bus_data();
            bus_trace[bus_trace_count].address = z80_read_bus_address();
            if(bus_trace_count < (MAX_BUS_STATES-1))
                bus_trace_count++;
        }
    }

    if(z80_bus_trace >= TR_BUS)
        report("\r\n|%04x|%02x|%s|%s|%s|",
                z80_read_bus_address(), z80_read_bus_data(),
                z80_mreq_asserted() ? "MREQ" : (z80_iorq_asserted() ? "IORQ" : "    "),
                z80_rd_asserted() ? "RD" : (z80_wr_asserted() ? "WR" : "  "),
                z80_m1_asserted() ? "M1" : "  ");
}

bool z80_supervised_mode(void)
{
    switch(z80_mode){
        case MODE_UNSUPERVISED:
        case MODE_UNSUPERVISED_DMA_IDLE:
        case MODE_UNSUPERVISED_DMA_READ:
        case MODE_UNSUPERVISED_DMA_WRITE:
            return false;
        case MODE_SUPERVISED:
        case MODE_SUPERVISED_DMA_IDLE:
        case MODE_SUPERVISED_DMA_READ:
        case MODE_SUPERVISED_DMA_WRITE:
        case MODE_ENCHANTED:
            return true;
    }
    assert(false);
}

z80_mode_t z80_set_dma_mode(bool writing)
{
    switch(z80_mode){
        case MODE_UNSUPERVISED:
        case MODE_UNSUPERVISED_DMA_IDLE:
        case MODE_UNSUPERVISED_DMA_READ:
        case MODE_UNSUPERVISED_DMA_WRITE:
            return z80_set_mode(writing ? MODE_UNSUPERVISED_DMA_WRITE : MODE_UNSUPERVISED_DMA_READ);
        case MODE_ENCHANTED:
        case MODE_SUPERVISED:
        case MODE_SUPERVISED_DMA_IDLE:
        case MODE_SUPERVISED_DMA_READ:
        case MODE_SUPERVISED_DMA_WRITE:
            return z80_set_mode(writing ? MODE_SUPERVISED_DMA_WRITE : MODE_SUPERVISED_DMA_READ);
    }
    assert(false);
}

const char *z80_mode_name(z80_mode_t mode)
{
    switch(z80_mode){
        case MODE_SUPERVISED:                   return "MODE_SUPERVISED";
        case MODE_UNSUPERVISED:                 return "MODE_UNSUPERVISED";
        case MODE_ENCHANTED:                    return "MODE_ENCHANTED";
        case MODE_UNSUPERVISED_DMA_IDLE:        return "MODE_UNSUPERVISED_DMA_IDLE";
        case MODE_UNSUPERVISED_DMA_READ:        return "MODE_UNSUPERVISED_DMA_READ";
        case MODE_UNSUPERVISED_DMA_WRITE:       return "MODE_UNSUPERVISED_DMA_WRITE";
        case MODE_SUPERVISED_DMA_IDLE:          return "MODE_SUPERVISED_DMA_IDLE";
        case MODE_SUPERVISED_DMA_READ:          return "MODE_SUPERVISED_DMA_READ";
        case MODE_SUPERVISED_DMA_WRITE:         return "MODE_SUPERVISED_DMA_WRITE";
        default:                                return "(unknown mode)";
    }
}

z80_mode_t z80_end_dma_mode(void)
{
    switch(z80_mode){
        case MODE_SUPERVISED:
        case MODE_UNSUPERVISED:
        case MODE_ENCHANTED:
            // do nothing
            return z80_mode;
        case MODE_UNSUPERVISED_DMA_IDLE:
        case MODE_UNSUPERVISED_DMA_READ:
        case MODE_UNSUPERVISED_DMA_WRITE:
            return z80_set_mode(MODE_UNSUPERVISED);
        case MODE_SUPERVISED_DMA_IDLE:
        case MODE_SUPERVISED_DMA_READ:
        case MODE_SUPERVISED_DMA_WRITE:
            return z80_set_mode(MODE_SUPERVISED);
    }
    assert(false);
}

// this tries to move us towards the desired mode, returning
// the mode it has moved us into (unlike z80_set_mode() which
// returns the previous mode)
static z80_mode_t z80_set_mode_internal(z80_mode_t new_mode)
{
    assert(new_mode != MODE_UNSUPERVISED_DMA_IDLE);
    assert(new_mode != MODE_SUPERVISED_DMA_IDLE);

    switch(z80_mode){
        case MODE_UNSUPERVISED:
            switch(new_mode){
                case MODE_UNSUPERVISED_DMA_READ:
                case MODE_UNSUPERVISED_DMA_WRITE:
                    do {
                        z80_set_busrq(true); // handle_z80_bus() may clear this
                        handle_z80_bus();
                    } while(!z80_busack_asserted());
                    z80_bus_master(new_mode == MODE_UNSUPERVISED_DMA_WRITE);
                    return new_mode;
                case MODE_SUPERVISED:
                default:
                    z80_clk_set_supervised(0.0);
                    // TODO: handle HALT etc
                    // TODO: trace a few opcodes until we know we are in sync with the decoder
                    while(!z80_m1_asserted() || z80_mreq_asserted()){ // stop at start of M1
                        z80_clock_pulse();
                        handle_z80_bus();
                    }
                    return MODE_SUPERVISED;
            }
            break;

        case MODE_UNSUPERVISED_DMA_IDLE:
            switch(new_mode){
                case MODE_UNSUPERVISED_DMA_READ:
                case MODE_UNSUPERVISED_DMA_WRITE:
                    z80_bus_master(new_mode == MODE_UNSUPERVISED_DMA_WRITE);
                    return new_mode;
                case MODE_UNSUPERVISED:
                default: 
                    z80_set_busrq(false);
                    return MODE_UNSUPERVISED;
            }
            break;

        case MODE_UNSUPERVISED_DMA_READ:
        case MODE_UNSUPERVISED_DMA_WRITE:
            switch(new_mode){
                case MODE_UNSUPERVISED_DMA_READ:
                    z80_bus_data_inputs();
                    return MODE_UNSUPERVISED_DMA_READ;
                case MODE_UNSUPERVISED_DMA_WRITE:
                    z80_bus_data_outputs();
                    return MODE_UNSUPERVISED_DMA_WRITE;
                case MODE_UNSUPERVISED:
                default: 
                    z80_bus_slave();
                    z80_set_busrq(false);
                    return MODE_UNSUPERVISED;
            }
            break;

        case MODE_SUPERVISED:
            switch(new_mode){
                case MODE_SUPERVISED_DMA_READ:
                case MODE_SUPERVISED_DMA_WRITE:
                    z80_set_ram_ce(false);
                    z80_enchanted_cpu_write(0x18); // JR ...
                    z80_enchanted_cpu_write(0xFE); // ... -2
                    z80_set_busrq(true);
                    z80_set_ram_ce(true);
                    while(!z80_busack_asserted())
                        z80_clock_pulse();
                    z80_bus_master(new_mode == MODE_SUPERVISED_DMA_WRITE);
                    return new_mode;
                case MODE_ENCHANTED:
                    z80_set_ram_ce(false);
                    return MODE_ENCHANTED;
                case MODE_UNSUPERVISED:
                default:
                    z80_clk_set_independent(CLK_FAST_FREQUENCY);
                    return MODE_UNSUPERVISED;
            }
            break;

        case MODE_SUPERVISED_DMA_IDLE:
            switch(new_mode){
                case MODE_SUPERVISED_DMA_READ:
                case MODE_SUPERVISED_DMA_WRITE:
                    z80_bus_master(new_mode == MODE_SUPERVISED_DMA_WRITE);
                    return new_mode;
                case MODE_SUPERVISED:
                default: 
                    z80_set_busrq(false);
                    while(z80_busack_asserted())
                        z80_clock_pulse();
                    // TODO may need to clock forward here until M1 is reached (see z80_switch_clk_supervised)
                    return MODE_SUPERVISED;
            }
            break;

        case MODE_SUPERVISED_DMA_READ:
        case MODE_SUPERVISED_DMA_WRITE:
            switch(new_mode){
                case MODE_SUPERVISED_DMA_READ:
                    z80_bus_data_inputs();
                    return MODE_SUPERVISED_DMA_READ;
                case MODE_SUPERVISED_DMA_WRITE:
                    z80_bus_data_outputs();
                    return MODE_SUPERVISED_DMA_WRITE;
                case MODE_SUPERVISED:
                default: 
                    z80_bus_slave();
                    z80_set_busrq(false);
                    while(z80_busack_asserted())
                        z80_clock_pulse();
                    // TODO may need to clock forward here until M1 is reached (see z80_switch_clk_supervised)
                    return MODE_SUPERVISED;
            }
            break;

        case MODE_ENCHANTED:
            // we can only transition to one state from here
            z80_set_ram_ce(true);
            return MODE_SUPERVISED;

        default:
            break;
    }

    assert(false);
}

#ifdef MODE_SWITCH_DEBUGGING
void z80_check_mode_correct(void)
{
    // this just checks that the interface between the Z80 and the Teensy
    // appears to be correctly configured for the mode we think we're in.
    switch(z80_mode){
        case MODE_UNSUPERVISED:
            assert(!z80_clk_is_supervised());
            assert(!z80_get_reset());
            assert(z80_get_ram_ce());
            assert(*portOutputRegister(Z80_BUSRQ));
            assert(!z80_busack_asserted());
            assert(!*portModeRegister(Z80_A0));
            assert(!*portModeRegister(Z80_D0));
            break;
        case MODE_UNSUPERVISED_DMA_IDLE:
            assert(!z80_clk_is_supervised());
            assert(!z80_get_reset());
            assert(z80_get_ram_ce());
            assert(!*portOutputRegister(Z80_BUSRQ));
            assert(z80_busack_asserted());
            assert(!*portModeRegister(Z80_A0));
            assert(!*portModeRegister(Z80_D0));
            break;
        case MODE_UNSUPERVISED_DMA_READ:
            assert(!z80_clk_is_supervised());
            assert(!z80_get_reset());
            assert(z80_get_ram_ce());
            assert(!*portOutputRegister(Z80_BUSRQ));
            assert(z80_busack_asserted());
            assert(*portModeRegister(Z80_A0));
            assert(!*portModeRegister(Z80_D0));
            break;
        case MODE_UNSUPERVISED_DMA_WRITE:
            assert(!z80_clk_is_supervised());
            assert(!z80_get_reset());
            assert(z80_get_ram_ce());
            assert(!*portOutputRegister(Z80_BUSRQ));
            assert(z80_busack_asserted());
            assert(*portModeRegister(Z80_A0));
            assert(*portModeRegister(Z80_D0));
            break;
        case MODE_SUPERVISED:
            assert(z80_clk_is_supervised());
            assert(!z80_get_reset());
            assert(z80_get_ram_ce());
            assert(*portOutputRegister(Z80_BUSRQ));
            assert(!z80_busack_asserted());
            assert(!*portModeRegister(Z80_A0));
            assert(!*portModeRegister(Z80_D0));
            break;
        case MODE_SUPERVISED_DMA_IDLE:
            assert(z80_clk_is_supervised());
            assert(!z80_get_reset());
            assert(z80_get_ram_ce());
            assert(!*portOutputRegister(Z80_BUSRQ));
            assert(z80_busack_asserted());
            assert(!*portModeRegister(Z80_A0));
            assert(!*portModeRegister(Z80_D0));
            break;
        case MODE_SUPERVISED_DMA_READ:
            assert(z80_clk_is_supervised());
            assert(!z80_get_reset());
            assert(z80_get_ram_ce());
            assert(!*portOutputRegister(Z80_BUSRQ));
            assert(z80_busack_asserted());
            assert(*portModeRegister(Z80_A0));
            assert(!*portModeRegister(Z80_D0));
            break;
        case MODE_SUPERVISED_DMA_WRITE:
            assert(z80_clk_is_supervised());
            assert(!z80_get_reset());
            assert(z80_get_ram_ce());
            assert(!*portOutputRegister(Z80_BUSRQ));
            assert(z80_busack_asserted());
            assert(*portModeRegister(Z80_A0));
            assert(*portModeRegister(Z80_D0));
            break;
        case MODE_ENCHANTED:
            assert(z80_clk_is_supervised());
            assert(!z80_get_reset());
            assert(!z80_get_ram_ce());
            assert(*portOutputRegister(Z80_BUSRQ));
            assert(!z80_busack_asserted());
            assert(!*portModeRegister(Z80_A0));
            assert(!*portModeRegister(Z80_D0));
            break;
    }
}
#endif

z80_mode_t z80_set_mode(z80_mode_t new_mode)
{
    if(z80_mode == new_mode)
        return z80_mode;

    z80_mode_t start_mode = z80_mode;
    z80_mode_t prev_mode = z80_mode;

#ifdef MODE_SWITCH_DEBUGGING
    report("[%s", z80_mode_name(z80_mode));
    z80_check_mode_correct();
#endif

    while(z80_mode != new_mode){
        z80_mode = z80_set_mode_internal(new_mode);
#ifdef MODE_SWITCH_DEBUGGING
        report("->%s", z80_mode_name(z80_mode));
#endif
        assert(z80_mode != prev_mode); // trap if we get stuck
        prev_mode = z80_mode;
    }
#ifdef MODE_SWITCH_DEBUGGING
    report("]\r\n");
    z80_check_mode_correct();
#endif

    return start_mode;
}
